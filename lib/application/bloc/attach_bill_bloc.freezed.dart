// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'attach_bill_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$AttachBillEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() picImage,
    required TResult Function() captureImage,
    required TResult Function() picPdf,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? picImage,
    TResult Function()? captureImage,
    TResult Function()? picPdf,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? picImage,
    TResult Function()? captureImage,
    TResult Function()? picPdf,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_PicImage value) picImage,
    required TResult Function(_CaptureImage value) captureImage,
    required TResult Function(_PicPdf value) picPdf,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_PicImage value)? picImage,
    TResult Function(_CaptureImage value)? captureImage,
    TResult Function(_PicPdf value)? picPdf,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_PicImage value)? picImage,
    TResult Function(_CaptureImage value)? captureImage,
    TResult Function(_PicPdf value)? picPdf,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AttachBillEventCopyWith<$Res> {
  factory $AttachBillEventCopyWith(
          AttachBillEvent value, $Res Function(AttachBillEvent) then) =
      _$AttachBillEventCopyWithImpl<$Res>;
}

/// @nodoc
class _$AttachBillEventCopyWithImpl<$Res>
    implements $AttachBillEventCopyWith<$Res> {
  _$AttachBillEventCopyWithImpl(this._value, this._then);

  final AttachBillEvent _value;
  // ignore: unused_field
  final $Res Function(AttachBillEvent) _then;
}

/// @nodoc
abstract class _$$_PicImageCopyWith<$Res> {
  factory _$$_PicImageCopyWith(
          _$_PicImage value, $Res Function(_$_PicImage) then) =
      __$$_PicImageCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_PicImageCopyWithImpl<$Res>
    extends _$AttachBillEventCopyWithImpl<$Res>
    implements _$$_PicImageCopyWith<$Res> {
  __$$_PicImageCopyWithImpl(
      _$_PicImage _value, $Res Function(_$_PicImage) _then)
      : super(_value, (v) => _then(v as _$_PicImage));

  @override
  _$_PicImage get _value => super._value as _$_PicImage;
}

/// @nodoc

class _$_PicImage implements _PicImage {
  const _$_PicImage();

  @override
  String toString() {
    return 'AttachBillEvent.picImage()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_PicImage);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() picImage,
    required TResult Function() captureImage,
    required TResult Function() picPdf,
  }) {
    return picImage();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? picImage,
    TResult Function()? captureImage,
    TResult Function()? picPdf,
  }) {
    return picImage?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? picImage,
    TResult Function()? captureImage,
    TResult Function()? picPdf,
    required TResult orElse(),
  }) {
    if (picImage != null) {
      return picImage();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_PicImage value) picImage,
    required TResult Function(_CaptureImage value) captureImage,
    required TResult Function(_PicPdf value) picPdf,
  }) {
    return picImage(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_PicImage value)? picImage,
    TResult Function(_CaptureImage value)? captureImage,
    TResult Function(_PicPdf value)? picPdf,
  }) {
    return picImage?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_PicImage value)? picImage,
    TResult Function(_CaptureImage value)? captureImage,
    TResult Function(_PicPdf value)? picPdf,
    required TResult orElse(),
  }) {
    if (picImage != null) {
      return picImage(this);
    }
    return orElse();
  }
}

abstract class _PicImage implements AttachBillEvent {
  const factory _PicImage() = _$_PicImage;
}

/// @nodoc
abstract class _$$_CaptureImageCopyWith<$Res> {
  factory _$$_CaptureImageCopyWith(
          _$_CaptureImage value, $Res Function(_$_CaptureImage) then) =
      __$$_CaptureImageCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_CaptureImageCopyWithImpl<$Res>
    extends _$AttachBillEventCopyWithImpl<$Res>
    implements _$$_CaptureImageCopyWith<$Res> {
  __$$_CaptureImageCopyWithImpl(
      _$_CaptureImage _value, $Res Function(_$_CaptureImage) _then)
      : super(_value, (v) => _then(v as _$_CaptureImage));

  @override
  _$_CaptureImage get _value => super._value as _$_CaptureImage;
}

/// @nodoc

class _$_CaptureImage implements _CaptureImage {
  const _$_CaptureImage();

  @override
  String toString() {
    return 'AttachBillEvent.captureImage()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_CaptureImage);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() picImage,
    required TResult Function() captureImage,
    required TResult Function() picPdf,
  }) {
    return captureImage();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? picImage,
    TResult Function()? captureImage,
    TResult Function()? picPdf,
  }) {
    return captureImage?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? picImage,
    TResult Function()? captureImage,
    TResult Function()? picPdf,
    required TResult orElse(),
  }) {
    if (captureImage != null) {
      return captureImage();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_PicImage value) picImage,
    required TResult Function(_CaptureImage value) captureImage,
    required TResult Function(_PicPdf value) picPdf,
  }) {
    return captureImage(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_PicImage value)? picImage,
    TResult Function(_CaptureImage value)? captureImage,
    TResult Function(_PicPdf value)? picPdf,
  }) {
    return captureImage?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_PicImage value)? picImage,
    TResult Function(_CaptureImage value)? captureImage,
    TResult Function(_PicPdf value)? picPdf,
    required TResult orElse(),
  }) {
    if (captureImage != null) {
      return captureImage(this);
    }
    return orElse();
  }
}

abstract class _CaptureImage implements AttachBillEvent {
  const factory _CaptureImage() = _$_CaptureImage;
}

/// @nodoc
abstract class _$$_PicPdfCopyWith<$Res> {
  factory _$$_PicPdfCopyWith(_$_PicPdf value, $Res Function(_$_PicPdf) then) =
      __$$_PicPdfCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_PicPdfCopyWithImpl<$Res> extends _$AttachBillEventCopyWithImpl<$Res>
    implements _$$_PicPdfCopyWith<$Res> {
  __$$_PicPdfCopyWithImpl(_$_PicPdf _value, $Res Function(_$_PicPdf) _then)
      : super(_value, (v) => _then(v as _$_PicPdf));

  @override
  _$_PicPdf get _value => super._value as _$_PicPdf;
}

/// @nodoc

class _$_PicPdf implements _PicPdf {
  const _$_PicPdf();

  @override
  String toString() {
    return 'AttachBillEvent.picPdf()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_PicPdf);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() picImage,
    required TResult Function() captureImage,
    required TResult Function() picPdf,
  }) {
    return picPdf();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? picImage,
    TResult Function()? captureImage,
    TResult Function()? picPdf,
  }) {
    return picPdf?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? picImage,
    TResult Function()? captureImage,
    TResult Function()? picPdf,
    required TResult orElse(),
  }) {
    if (picPdf != null) {
      return picPdf();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_PicImage value) picImage,
    required TResult Function(_CaptureImage value) captureImage,
    required TResult Function(_PicPdf value) picPdf,
  }) {
    return picPdf(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_PicImage value)? picImage,
    TResult Function(_CaptureImage value)? captureImage,
    TResult Function(_PicPdf value)? picPdf,
  }) {
    return picPdf?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_PicImage value)? picImage,
    TResult Function(_CaptureImage value)? captureImage,
    TResult Function(_PicPdf value)? picPdf,
    required TResult orElse(),
  }) {
    if (picPdf != null) {
      return picPdf(this);
    }
    return orElse();
  }
}

abstract class _PicPdf implements AttachBillEvent {
  const factory _PicPdf() = _$_PicPdf;
}

/// @nodoc
mixin _$AttachBillState {
  bool get isLoading => throw _privateConstructorUsedError;
  List<File> get data => throw _privateConstructorUsedError;
  Failure? get error => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $AttachBillStateCopyWith<AttachBillState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AttachBillStateCopyWith<$Res> {
  factory $AttachBillStateCopyWith(
          AttachBillState value, $Res Function(AttachBillState) then) =
      _$AttachBillStateCopyWithImpl<$Res>;
  $Res call({bool isLoading, List<File> data, Failure? error});

  $FailureCopyWith<$Res>? get error;
}

/// @nodoc
class _$AttachBillStateCopyWithImpl<$Res>
    implements $AttachBillStateCopyWith<$Res> {
  _$AttachBillStateCopyWithImpl(this._value, this._then);

  final AttachBillState _value;
  // ignore: unused_field
  final $Res Function(AttachBillState) _then;

  @override
  $Res call({
    Object? isLoading = freezed,
    Object? data = freezed,
    Object? error = freezed,
  }) {
    return _then(_value.copyWith(
      isLoading: isLoading == freezed
          ? _value.isLoading
          : isLoading // ignore: cast_nullable_to_non_nullable
              as bool,
      data: data == freezed
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as List<File>,
      error: error == freezed
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as Failure?,
    ));
  }

  @override
  $FailureCopyWith<$Res>? get error {
    if (_value.error == null) {
      return null;
    }

    return $FailureCopyWith<$Res>(_value.error!, (value) {
      return _then(_value.copyWith(error: value));
    });
  }
}

/// @nodoc
abstract class _$$_AttachBillStateCopyWith<$Res>
    implements $AttachBillStateCopyWith<$Res> {
  factory _$$_AttachBillStateCopyWith(
          _$_AttachBillState value, $Res Function(_$_AttachBillState) then) =
      __$$_AttachBillStateCopyWithImpl<$Res>;
  @override
  $Res call({bool isLoading, List<File> data, Failure? error});

  @override
  $FailureCopyWith<$Res>? get error;
}

/// @nodoc
class __$$_AttachBillStateCopyWithImpl<$Res>
    extends _$AttachBillStateCopyWithImpl<$Res>
    implements _$$_AttachBillStateCopyWith<$Res> {
  __$$_AttachBillStateCopyWithImpl(
      _$_AttachBillState _value, $Res Function(_$_AttachBillState) _then)
      : super(_value, (v) => _then(v as _$_AttachBillState));

  @override
  _$_AttachBillState get _value => super._value as _$_AttachBillState;

  @override
  $Res call({
    Object? isLoading = freezed,
    Object? data = freezed,
    Object? error = freezed,
  }) {
    return _then(_$_AttachBillState(
      isLoading: isLoading == freezed
          ? _value.isLoading
          : isLoading // ignore: cast_nullable_to_non_nullable
              as bool,
      data: data == freezed
          ? _value._data
          : data // ignore: cast_nullable_to_non_nullable
              as List<File>,
      error: error == freezed
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as Failure?,
    ));
  }
}

/// @nodoc

class _$_AttachBillState implements _AttachBillState {
  const _$_AttachBillState(
      {required this.isLoading, required final List<File> data, this.error})
      : _data = data;

  @override
  final bool isLoading;
  final List<File> _data;
  @override
  List<File> get data {
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_data);
  }

  @override
  final Failure? error;

  @override
  String toString() {
    return 'AttachBillState(isLoading: $isLoading, data: $data, error: $error)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_AttachBillState &&
            const DeepCollectionEquality().equals(other.isLoading, isLoading) &&
            const DeepCollectionEquality().equals(other._data, _data) &&
            const DeepCollectionEquality().equals(other.error, error));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(isLoading),
      const DeepCollectionEquality().hash(_data),
      const DeepCollectionEquality().hash(error));

  @JsonKey(ignore: true)
  @override
  _$$_AttachBillStateCopyWith<_$_AttachBillState> get copyWith =>
      __$$_AttachBillStateCopyWithImpl<_$_AttachBillState>(this, _$identity);
}

abstract class _AttachBillState implements AttachBillState {
  const factory _AttachBillState(
      {required final bool isLoading,
      required final List<File> data,
      final Failure? error}) = _$_AttachBillState;

  @override
  bool get isLoading => throw _privateConstructorUsedError;
  @override
  List<File> get data => throw _privateConstructorUsedError;
  @override
  Failure? get error => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$_AttachBillStateCopyWith<_$_AttachBillState> get copyWith =>
      throw _privateConstructorUsedError;
}
